pdb:
  enabled: true
  minAvailable: 1

replicas: 1

resources:
  requests:
    cpu: 0.2
    memory: 512Mi

#storage:
  #capacity: 2G

rbac:
  enabled: true

image:
  name: jupyterhub/k8s-binderhub
  tag: '0.2.0-n139.ha1f9f09'

# registry here is only used to create docker config.json
registry:
  url: "https://docker.jupyteronline.com"
  username: "admin"
  password: "2020@alpha"

service:
  type: ClusterIP
  labels: {}
  annotations:
    prometheus.io/scrape: 'true'
  nodePort:

config:
  BinderHub:
    build_image: jupyter/repo2docker:0.11.0-31.g1776b79
    auth_enabled: true  # server folked like jupyter-jih-xxxxx
    #use_named_servers: true
    use_registry: true
    image_prefix: docker.jupyteronline.com/
    hub_url: https://hub.jupyteronline.com
    log_level: 10
  DockerRegistry:
    url: "https://docker.jupyteronline.com" # the actual v2 registry url

extraConfig: {}

# have to set cors.allowOrigin twice:
# once in top-level cors.allowOrigin,
# and again in jupyterhub.hub.extraConfigMap.cors.allowOrigin

# Using YAML anchors, `&cors` for the first appearance and `*cors` for subsequent
# appearances, allows us to remove redundancy in this (BinderHub) `values.yaml`.
# The anchors do not extend beyond this file.
# As such, users must set `cors` separately for their own user `values.yaml` for notebooks.
# `cors` will be set separately in the user `values.yaml` and binderhub`values.yaml`.
# The same anchor pattern (`&cors`, `*cors`) can be used in the user `values.yaml`.

cors: &cors
  allowOrigin:

jupyterhub:
  scheduling:
    userScheduler:
      enabled: true
    podPriority:
      enabled: true
    userPlaceholder:
      enabled: true
      replicas: 2
  cull:
    enabled: true
    timeout: 3600
    every: 300
    users: false
  custom:
    cors: *cors
    binderauth_enabled: true
  rbac:
    enabled: true
  proxy:
    secretToken: 53a338a0aee98f74c2b431cac2ff7cc0e59d52be13aeea07a0145750529e050e
    nginx:
      proxBodySize: 512m
  storage:
    capacity: 2G
  hub:
    #allowNamedServers: true
    #namedServerLimitPerUser: 10
    redirectToServer: false
    baseUrl: /
    services:
      binder:
        admin: true
        apiToken: 53a338a0aee98f74c2b431cac2ff7cc0e59d52be13aeea07a0145750529e050e
        oauth_no_confirm: true
        #oauth_redirect_uri: "https://binder.jupyteronline.com/oauth_callback"
        #oauth_client_id: "jhub"
    db:
      type: postgres
      upgrade: true
      password: "@postgres"
      url: "postgresql+psycopg2://jupyterhub@postgres-postgresql/jupyterhub"
      pvc:
        storageClassName: nfs-client
    extraConfig:
      jupyterlab: |
        #c.Authenticator.auto_login = True
        c.Spawner.default_url = '/lab'
        #c.Spawner.cmd = ['jupyter-labhub']
      hub: |
        c.JupyterHub.tornado_settings = {
          'headers': {
            'Content-Security-Policy': "base-uri 'self'"
          },
        }
      hub_extra: |
        c.KubeSpawner.args = ['--allow-root']
        c.JupyterHub.redirect_to_server = False
      spawner: >-
        c.Spawner.args = ["--NotebookApp.tornado_settings={ \
          'headers':{                                    \
            'Content-Security-Policy': \"base-uri 'self' \", \
          }, \
        }"]
      myConfig:  |
        c.KubeSpawner.pod_name_template = 'jupyter-{username}{servername}'
      binder: |
        from kubespawner import KubeSpawner
        #class BinderSpawner(KubeSpawner):
        #  def start(self):
        #    if 'image' in self.user_options:
        #      # binder service sets the image spec via user options
        #      self.image = self.user_options[Unicode('image')]
        #    return super().start()

        class BinderSpawner(KubeSpawner):
            def get_args(self):
                if auth_enabled:
                    args = super().get_args()
                else:
                    args = [
                        '--ip=0.0.0.0',
                        '--port=%i' % self.port,
                        '--NotebookApp.base_url=%s' % self.server.base_url,
                        '--NotebookApp.token=%s' % self.user_options['token'],
                        '--NotebookApp.trust_xheaders=True',
                    ]
                    allow_origin = cors.get('allowOrigin')
                    if allow_origin:
                        args.append('--NotebookApp.allow_origin=' + allow_origin)
                    args += self.args
                return args

            def start(self):
                if not auth_enabled:
                    if 'token' not in self.user_options:
                        raise web.HTTPError(400, "token required")
                    if 'image' not in self.user_options:
                        raise web.HTTPError(400, "image required")
                if 'image' in self.user_options:
                    self.image = self.user_options['image']
                return super().start()

            def get_env(self):
                env = super().get_env()
                if 'repo_url' in self.user_options:
                    env['BINDER_REPO_URL'] = self.user_options['repo_url']
                for key in (
                        'binder_ref_url',
                        'binder_launch_host',
                        'binder_persistent_request',
                        'binder_request'):
                    if key in self.user_options:
                        env[key.upper()] = self.user_options[key]
                return env

        c.JupyterHub.spawner_class = BinderSpawner

  auth:
    type: ldap
    ldap:
      server:
        address: ldap-openldap.auth.svc
      dn:
        templates:
          - 'uid={username},ou=People,dc=jupyteronline,dc=com'

  prePuller:
    hook:
      enabled: false
    continuous:
      enabled: false

  singleuser:
    cmd: jupyterhub-singleuser
    cpu:
      limit: 8
      guarantee: 4
    memory:
      limit: 8G
      guarantee: 4G
    storage:
      type: dynamic
      capacity: 1Gi
      dynamic:
        storageClass: nfs-client
      extraVolumes:
        - name: jupyterhub-shared
          persistentVolumeClaim:
            claimName: jupyterhub-shared-pvc
      extraVolumeMounts:
        - name: jupyterhub-shared
          mountPath: /home/jovyan/shared
    image:
      name: nielsbohr/tensorflow-notebook
      tag: latest
    profileList:
      #- display_name: "Welcome_to_Jupyter"
      #  description: "If you want the additional bells and whistles: Python, R, and Julia."
      #  default: true
      #  kubespawner_override:
      #    lifecycle_hooks:
      #      postStart:
      #        exec:
      #          command: ["sh","-c","rm -rf Welcome_to_Jupyter && git clone https://github.com/jupyteronline/Welcome_to_Jupyter.git"]
      - display_name: "Tensorflow_2 environment"
        description: "TensorFlow is an end-to-end open source platform for machine learning."
      #- display_name: "Teaching environment"
      #  description: "Lab, Classroom, or Business"
      #  kubespawner_override:
      #    image: pupster90/io:v3.0.7
      #    lifecycle_hooks:
      #      postStart:
      #        exec:
      #          command: ["sh","-c","rm -rf Welcome_to_io_Hub && git clone https://github.com/jupyteronline/Welcome_to_io_Hub.git"]
      - display_name: "Pyspark environment"
        description: "PySpark is the collaboration of Apache Spark and Python."
        kubespawner_override:
          image: binderhubonline/pyspark-notebook:1.0.2
          #image: jupyter/pyspark-notebook:678ada768ab1
      #- display_name: "GeoPyspark environment"
      #  description: "GeoPySpark is a Python library designed to support the processing of large geospatial data."
      #  kubespawner_override:
      #    image: binderhubonline/geopyspark-notebook:1.4.0
      #    lifecycle_hooks:
      #      postStart:
      #        exec:
      #          command: ["sh","-c","jupyterhub --no-ssl --Spawner.notebook_dir=/home/hadoop/notebooks"]

          #extraConfig:
          #  jupyterlab: |
          #    c.Spawner.default_url = "/lab"
              #c.Spawner.cmd = ['jupyter-labhub']
              #c.Spawner.notebook_dir=/home/jovyan/notebooks
              #c.Spawner.cmd = "-f /etc/jupterhub/jupyterhub_config_github.py"
      - display_name: "KFP environment"
        description: "Kubeflows Pipeline service"
        kubespawner_override:
          image: jupyterbook/kfp:1.0.1
          extraConfig:
            jupyterlab: |
              c.KubeSpawner.default_url = "/lab"
              c.KubeSpawner.cmd = ['jupyter-labhub']
              c.KubeSpawner.working_dir = Unicode('/home/jovyan')
              c.KubeSpawner.notebook_dir = Unicode('/home/jovyan')
              c.KubeSpawner.cmd = "-f /etc/jupterhub/jupyterhub_config_github.py"
      #- display_name: "Spark Cluster"
      #  description: "Enterprise-gateway to Cluster"
      #  kubespawner_override:
      #    image: elyra/kernel-spark-py:2.1.0
      #    #image: elyra/enterprise-gateway:2.1.0
      #    extraEnv:
      #      KG_URL: https://egw.jupyteronline.com
      #      KG_HTTP_USER: jovyan
      #      KERNEL_USERNAME: jovyan
      #      KG_REQUEST_TIMEOUT: 60

deployment:
  labels: {}

dind:
  enabled: false
  initContainers: []
  daemonset:
    image:
      name: docker
      tag: 19.03.5-dind
    # Additional command line arguments to pass to dockerd
    extraArgs: []
  storageDriver: overlay2
  resources: {}
  hostSocketDir: /var/run/dind
  hostLibDir: /var/lib/dind

imageCleaner:
  enabled: true
  image:
    name: jupyterhub/k8s-image-cleaner
    tag: '0.2.0-n096.h4e521a1'
    repository: jupyterhub/k8s-image-cleaner
  # delete an image at most every 5 seconds
  delay: 5
  # Interpret threshold values as percentage or bytes
  imageGCThresholdType: "relative"
  # when 80% of inodes are used,
  # cull images until it drops below 60%
  imageGCThresholdHigh: 80
  imageGCThresholdLow: 60
  # cull images on the host docker as well as dind
  host:
    enabled: true
    dockerSocket: /var/run/docker.sock
    dockerLibDir: /var/lib/docker

ingress:
  enabled: false
  https:
    enabled: false
    type: kube-lego
  hosts:
    - chart-example.local
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  tls: []
    # Secrets must be manually created in the namespace.
    # - secretName: chart-example-tls
    #   hosts:
    #     - chart-example.local

initContainers: []
extraVolumes: []
extraVolumeMounts: []
extraEnv: []
